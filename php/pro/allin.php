<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use React\Async;
use React\Promise\PromiseInterface;

class allin extends \ccxt\async\allin {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchLiquidations' => false,
                'watchLiquidationsForSymbols' => false,
                'watchMyLiquidations' => false,
                'watchMyLiquidationsForSymbols' => false,
                'watchBidsAsks' => false,
                'watchMyTrades' => false,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => false,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => false,
                'watchOrders' => true,
                'watchOrdersForSymbols' => false,
                'watchPositions' => false,
                'watchTicker' => false,
                'watchTickers' => false,
                'watchTrades' => true,
                'watchTradesForSymbols' => false,
            ),
            'urls' => array(
                'test' => array(
                    'ws' => array(
                        'spot' => 'wss://ws.allintest.pro/ws',
                        'futures' => 'wss://ws.allintest.pro/ws',
                        'public' => 'wss://ws.allintest.pro/ws',
                        'private' => 'wss://ws.allintest.pro/ws',
                    ),
                ),
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://ws.allintest.pro/ws',
                        'futures' => 'wss://ws.allintest.pro/ws',
                        'public' => 'wss://ws.allintest.pro/ws',
                        'private' => 'wss://ws.allintest.pro/ws',
                    ),
                ),
                'doc' => 'https://allinexchange.github.io/spot-docs/v1/en/#verified-api',
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 27000,
            ),
            'options' => array(
                'returnRateLimits' => false,
            ),
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             */
            // $response = array( 'id' => 100,
            //     'method' => 'update.depth',
            //     'result' => array( 'data':
            //         array( 'asks' => array( array( 'price' => '68000.0', 'quantity' => '0.357100' ),
            //             array( 'price' => '68123.5', 'quantity' => '0.230000' ) ),
            //         'bids' => array( array( 'price' => '67890.9', 'quantity' => '0.002000' ),
            //             array( 'price' => '67890.4', 'quantity' => '0.001000' ),
            //             array( 'price' => '65000.2', 'quantity' => '0.300000' ),
            //             array( 'price' => '62000.0', 'quantity' => '1.999000' ),
            //             array( 'price' => '60000.0', 'quantity' => '1.100000' ),
            //             array( 'price' => '8850.2', 'quantity' => '0.200000' ) ),
            //         'symbol' => 'BTC-USDT',
            //         'timestamp' => 1720856594882,
            //         'topic' => 'depth:step1:BTC-USDT',
            //         'tpp' => 7 ),
            //     'merge' => 'step1' ),
            //     'error' => null );
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' watchOrderBook() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $type_ = 'spot';
            $url = $this->urls['api']['ws'][$type_];
            $reqId = $this->request_id();
            $merge = 'step0';
            $request = array(
                'method' => 'subscribe.depth',
                'params' => array(
                    'market' => $marketId,
                    'merge' => $merge,
                ),
            );
            $messageHash = 'depth:' . $merge . ':' . $marketId;  // 'topic' => 'depth:step1:BTC-USDT'
            $request['id'] = $reqId;
            $orderbook = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_balance(?array () $params): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->portfolioMargin] set to true if you would like to watch the balance of a portfolio margin account
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             */
            Async\await($this->load_markets());
            $type_ = 'spot';
            $url = $this->urls['api']['ws'][$type_];
            Async\await($this->authenticate($url));
            $messageHash = 'update.asset';
            $request = array(
                'method' => 'subscribe.asset',
                'params' => array(),
                'id' => $this->request_id(),
            );
            $balances = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            return $balances;
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' watchOrderBook() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $messageHash = 'orders:' . $marketId;
            $type_ = 'spot';
            $url = $this->urls['api']['ws'][$type_];
            Async\await($this->authenticate($url));
            $request = array(
                'method' => 'subscribe.orders',
                'params' => array(
                    'market' => $marketId,
                ),
                'id' => $this->request_id(),
            );
            $orders = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $orders;
        }) ();
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $type_ = 'spot';
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $url = $this->urls['api']['ws'][$type_];
            $reqId = $this->request_id();
            $messageHash = 'kline:' . $interval . ':' . $marketId;
            $request = array(
                'method' => 'subscribe.kline',
                'params' => array(
                    'period' => $interval,
                    'market' => $marketId,
                ),
                'id' => $reqId,
            );
            $ohlcv = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function authenticate($url, $params = array ()) {
        return Async\async(function () use ($url, $params) {
            $this->check_required_credentials();
            $messageHash = 'sign';
            $client = $this->client($url);
            $future = $client->future ($messageHash);
            $authenticated = $this->safe_value($client->subscriptions, $messageHash);
            $result = array();
            if ($authenticated === null) {
                $nonce = (string) $this->nonce();
                $ts = $nonce;
                $client_id = $this->apiKey;
                $s = 'client_id=' . $client_id . '&$nonce=' . $nonce . '&$ts=' . $ts;
                $v = $this->hmac($this->encode($s), $this->encode($this->secret), 'sha256');
                $result = array( 'method' => 'sign',
                    'id' => $this->request_id(),
                    'params' => array( 'client_id' => $client_id,
                        'ts' => $ts,
                        'nonce' => $nonce,
                        'sign' => $v ));
                $this->watch($url, $messageHash, $result, $messageHash);
            }
            return Async\await($future);
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        // $response = array( 'id' => 100,
        //     'method' => 'update.depth',
        //     'result' => array( 'data':
        //         array( 'asks' => array( array( 'price' => '68000.0', 'quantity' => '0.357100' ),
        //             array( 'price' => '68123.5', 'quantity' => '0.230000' ) ),
        //         'bids' => array( array( 'price' => '67890.9', 'quantity' => '0.002000' ),
        //             array( 'price' => '67890.4', 'quantity' => '0.001000' ),
        //             array( 'price' => '65000.2', 'quantity' => '0.300000' ),
        //             array( 'price' => '62000.0', 'quantity' => '1.999000' ),
        //             array( 'price' => '60000.0', 'quantity' => '1.100000' ),
        //             array( 'price' => '8850.2', 'quantity' => '0.200000' ) ),
        //         'symbol' => 'BTC-USDT',
        //         'timestamp' => 1720856594882,
        //         'topic' => 'depth:step1:BTC-USDT',
        //         'tpp' => 7 ),
        //     'merge' => 'step1' ),
        //     'error' => null );
        $result = $this->safe_dict($message, 'result');
        $abData = $this->safe_dict($result, 'data');
        $marketId = $this->safe_string($abData, 'symbol');
        $market = $this->safe_market($marketId, null, null);
        $timestamp = $this->safe_integer($abData, 'timestamp');
        $messageHash = $this->safe_string($abData, 'topic');
        $symbol = $market['symbol'];
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
            $this->orderbooks[$symbol]['symbol'] = $symbol;
        }
        $orderbook = $this->orderbooks[$symbol];
        $asks = $this->safe_list($abData, 'asks', array());
        $bids = $this->safe_list($abData, 'bids', array());
        $this->handle_deltas($orderbook['asks'], $asks);
        $this->handle_deltas($orderbook['bids'], $bids);
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 'price');
        $amount = $this->safe_float($delta, 'quantity');
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_ohlcv(Client $client, $message) {
        // $message = array(
        //     'id' => 1,
        //     'method' => 'update.kline',
        //     'error' => null, // 错误响应
        //     'result' => array(
        //         'data' => array(
        //             'symbol' => 'BTC-USDT',
        //             'ticks' => array(
        //                 array(
        //                     'close' => '101.000000',
        //                     'high' => '101.000000',
        //                     'low' => '101.000000',
        //                     'open' => '101.000000',
        //                     'timestamp' => 1672910460,
        //                     'volume' => '0',
        //                 ),
        //             ),
        //             'timestamp' => 1672910460000,
        //             'topic' => 'kline:1Min:BTC-USDT',
        //             'tpp' => 1,
        //             'type' => '1Min',
        //         ), // 返回数据
        //         'period' => '1Min',
        //     ), // 结果集
        // );
        $result = $this->safe_dict($message, 'result');
        $klineData = $this->safe_dict($result, 'data');
        if (!$klineData) {
            return;
        }
        // $marketId = $this->safe_string($klineData, 'symbol');
        // $market = $this->safe_market($marketId, null, null);
        // $timestamp = $this->safe_integer($klineData, 'timestamp');
        // $messageHash = $this->safe_string($klineData, 'topic');
        $ticks = $this->safe_string($klineData, 'ticks');
        for ($i = 0; $i < count($ticks); $i++) {
            $tick = $ticks[$i];
            $this->log($tick);
            // $parsed = array(
            //     $this->safe_integer($tick, 'timestamp'),
            //     $this->safe_float($tick, 'open'),
            //     $this->safe_float($tick, 'high'),
            //     $this->safe_float($tick, 'low'),
            //     $this->safe_float($tick, 'close'),
            //     $this->safe_float($tick, 'volume'),
            // );
        }
    }

    public function handle_order(Client $client, $message) {
        // $orderMessage = array(
        //     'id' => 0,
        //     'method' => 'update.orders',
        //     'result' => array(
        //         'frm' => 'USDT',
        //         'left' => '0.100000',
        //         'match_amt' => '0',
        //         'match_price' => '60000.21',
        //         'match_qty' => '0',
        //         'order_id' => '102',
        //         'order_sub_type' => 0,
        //         'order_type' => 1,
        //         'price' => '60000.21',
        //         'quantity' => '0.100000',
        //         'real_order_id' => '102',
        //         'side' => 1,
        //         'status' => 2,
        //         'stop_price' => '0',
        //         'symbol' => 'BTC-USDT',
        //         'ticker_id' => 7,
        //         'timestamp' => 1721031092,
        //         'to' => 'BTC',
        //         'topic' => 'orders:BTC-USDT',
        //         'tpp' => 7,
        //         'trade_no' => '40545373062180505095221',
        //     ),
        //     'error' => null,
        // );
        $result = $this->safe_dict($message, 'result');
        $timestamp = $this->safe_integer($result, 'timestamp');
        $allinOrderStatus = $this->safe_integer($result, 'status');
        $allinSymbol = $this->safe_string($result, 'symbol');
        $market = $this->safe_market($allinSymbol);
        if (!$market) {
            return;
        }
        $allinOrderType = $this->force_string($this->safe_integer($result, 'order_type'));
        $allinOrderSide = $this->safe_integer($result, 'side');
        $messageHash = $this->safe_string($result, 'topic');
        $cost = $this->safe_string($result, 'match_amt', '0');
        $order = array(
            'id' => $this->safe_string($result, 'order_id'),
            'clientOrderId' => $this->safe_string($result, 'trade_no'),
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => $timestamp,
            'lastUpdateTimestamp' => $timestamp,
            'status' => $this->parse_order_status($allinOrderStatus),
            'symbol' => $market['symbol'],
            'type' => $this->parseOrderType ($allinOrderType),
            'timeInForce' => null,
            'side' => $this->parseOrderSide ($allinOrderSide),
            'price' => $this->safe_float($result, 'price'),
            'average' => $this->safe_float($result, 'match_price'),
            'amount' => $this->safe_float($result, 'quantity'),
            'filled' => $this->safe_float($result, 'match_qty'),
            'remaining' => $this->safe_float($result, 'left'),
            'stopPrice' => null,
            'triggerPrice' => null,
            'takeProfitPrice' => null,
            'stopLossPrice' => null,
            'cost' => $cost,
            'trades' => array(),
            'fee' => null,
            'reduceOnly' => null,
            'postOnly' => null,
            'info' => $result,
        );
        $safeOrder = $this->safe_order($order, $market);
        $client->resolve ($safeOrder, $messageHash);
    }

    public function handle_balance(Client $client, $message) {
        // {
        //     "id" => 1,
        //     "method" => "update.asset",
        //     "error" => null, //错误响应
        //     "result" => {
        //         "available" => "999909.4",
        //         "freeze" => "90.6",
        //         "symbol" => "USDT",
        //         "topic" => "accounts",
        //         "total" => "1000000"
        //     } //结果集
        // }
        $messageHash = 'update.asset';
        $result = $this->safe_dict($message, 'result');
        $token = $this->safe_string($result, 'symbol');
        if ($this->balance === null) {
            $this->balance = array();
        }
        if ($this->balance['info'] === null) {
            $this->balance['info'] = array();
        }
        $this->balance['info'][$token] = $result;
        $timestamp = $this->microseconds();
        $this->balance['timestamp'] = $timestamp;
        $this->balance['datetime'] = $this->iso8601($timestamp);
        $this->balance[$token] = array(
            'free' => $this->safe_string($result, 'available'),
            'total' => $this->safe_string($result, 'total'),
            'used' => $this->safe_string($result, 'freeze'),
        );
        $this->balance = $this->safe_balance($this->balance);
        $client->resolve ($this->balance, $messageHash);
    }

    public function ping($client) {
        return array(
            'id' => $this->request_id(),
            'method' => 'ping',
            'params' => array(),
        );
    }

    public function handle_pong($client, $message) {
        $client->lastPong = $this->microseconds();
        return $message;
    }

    public function handle_authenticate(Client $client, $message) {
        // array( id => 1, method => 'sign', result => 'login success', $error => null )
        $errorStr = $message['error'];
        $messageHash = 'sign';
        if (!$errorStr) {
            $future = $this->safe_value($client->futures, $messageHash);
            $future->resolve (true);
        } else {
            $error = new AuthenticationError ($this->id . ' ' . $this->json($errorStr));
            $client->reject ($error, $messageHash);
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions[$messageHash]);
            }
        }
        return $message;
    }

    public function handle_error_message(Client $client, $message): bool {
        // $response = array( 'id' => 100,
        //     'method' => 'update.depth',
        //     'result' => array( 'data':
        //         array( 'asks' => array( array( 'price' => '68000.0', 'quantity' => '0.357100' ),
        //             array( 'price' => '68123.5', 'quantity' => '0.230000' ) ),
        //         'bids' => array( array( 'price' => '67890.9', 'quantity' => '0.002000' ),
        //             array( 'price' => '67890.4', 'quantity' => '0.001000' ),
        //             array( 'price' => '65000.2', 'quantity' => '0.300000' ),
        //             array( 'price' => '62000.0', 'quantity' => '1.999000' ),
        //             array( 'price' => '60000.0', 'quantity' => '1.100000' ),
        //             array( 'price' => '8850.2', 'quantity' => '0.200000' ) ),
        //         'symbol' => 'BTC-USDT',
        //         'timestamp' => 1720856594882,
        //         'topic' => 'depth:step1:BTC-USDT',
        //         'tpp' => 7 ),
        //     'merge' => 'step1' ),
        //     'error' => null );
        $error = $message['error'];
        if ($error) {
            throw new ExchangeError($this->id . ' ' . $error);
        }
        return false;
    }

    public function handle_message(Client $client, $message) {
        $error = $this->safe_value($message, 'error');
        $this->log('message => ', $message);
        if ($error) {
            $this->handle_error_message($client, $message);
        }
        $methodsDict = array(
            'update.depth' => array($this, 'handle_order_book'),
            'subscribe.depth' => array($this, 'handle_order_book'),
            'subscribe.kline' => array($this, 'handle_ohlcv'),
            'update.kline' => array($this, 'handle_ohlcv'),
            'update.orders' => array($this, 'handle_order'),
            'update.asset' => array($this, 'handle_balance'),
            'ping' => array($this, 'handle_pong'),
            'sign' => array($this, 'handle_authenticate'),
            'subscribe.quote' => null,
        );
        $methodStr = $this->safe_string($message, 'method');
        $method = $this->safe_value($methodsDict, $methodStr);
        if ($method) {
            $method($client, $message);
        }
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }
}
