<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\BaseError;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use React\Async;
use React\Promise\PromiseInterface;

class allin extends \ccxt\async\allin {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchLiquidations' => false,
                'watchLiquidationsForSymbols' => false,
                'watchMyLiquidations' => false,
                'watchMyLiquidationsForSymbols' => false,
                'watchBidsAsks' => false,
                'watchMyTrades' => false,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => false,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => false,
                'watchOrders' => true,
                'watchOrdersForSymbols' => false,
                'watchPositions' => false,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
                'watchTradesForSymbols' => false,
            ),
            'urls' => array(
                'test' => array(
                    'ws' => array(
                        'spot' => 'ws://ws.aie.test/ws',
                        'future' => 'ws://futuresws.aie.test/wsf',
                        'swap' => 'ws://futuresws.aie.test/wsf',
                    ),
                ),
                'api' => array(
                    'ws' => array(
                        'spot' => 'ws://ws.aie.prod/ws',
                        'future' => 'ws://futuresws.aie.prod/wsf',
                        'swap' => 'ws://futuresws.aie.prod/wsf',
                    ),
                ),
                'doc' => 'https://allinexchange.github.io/spot-docs/v1/en/#verified-api',
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 27000,
            ),
            'options' => array(
                'returnRateLimits' => false,
            ),
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit = 50, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             */
            // $response = array( 'id' => 100,
            //     'method' => 'update.depth',
            //     'result' => array( 'data':
            //         array( 'asks' => array( array( 'price' => '68000.0', 'quantity' => '0.357100' ),
            //             array( 'price' => '68123.5', 'quantity' => '0.230000' ) ),
            //         'bids' => array( array( 'price' => '67890.9', 'quantity' => '0.002000' ),
            //             array( 'price' => '67890.4', 'quantity' => '0.001000' ),
            //             array( 'price' => '65000.2', 'quantity' => '0.300000' ),
            //             array( 'price' => '62000.0', 'quantity' => '1.999000' ),
            //             array( 'price' => '60000.0', 'quantity' => '1.100000' ),
            //             array( 'price' => '8850.2', 'quantity' => '0.200000' ) ),
            //         'symbol' => 'BTC-USDT',
            //         'timestamp' => 1720856594882,
            //         'topic' => 'depth:step1:BTC-USDT',
            //         'tpp' => 7 ),
            //     'merge' => 'step1' ),
            //     'error' => null );
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' watchOrderBook() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $type_ = null;
            $request = null;
            $merge = null;
            if ($market['spot']) {
                $type_ = 'spot';
                $merge = 'step0';
                $request = array(
                    'method' => 'subscribe.depth',
                    'params' => array(
                        'market' => $marketId,
                        'merge' => $merge,
                    ),
                );
            } else {
                $merge = '0';
                $type_ = 'future';
                $request = array(
                    'method' => 'subscribe.depth',
                    'params' => array(
                        'market' => $marketId,
                        'merge' => $merge,
                    ),
                );
            }
            $url = $this->urls['api']['ws'][$type_];
            $reqId = $this->request_id();
            $messageHash = 'depth:' . ':' . $marketId;  // 'topic' => 'depth:step1:BTC-USDT'
            $request['id'] = $reqId;
            $orderbook = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @see https://allinexchange.github.io/spot-docs/v1/en/#websocket-guide
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            // $response = array(
            //     'id' => 1,
            //     'method' => 'update.quote',
            //     'error' => null, // 错误响应
            //     'result' => array(
            //         'data' => array(
            //             'symbol' => 'BTC-USDT',
            //             'timestamp' => 1673417148,
            //             'topic' => 'quotes',
            //             'price' => '100.21', // 价格
            //             'volume' => '0',
            //             'amount' => '0',
            //             'high' => '100.21',
            //             'low' => '100.21',
            //             'change' => '0',
            //             'tpp' => 1,
            //             'l_price' => '100.21',
            //         ), // 返回数据
            //         'market' => 'BTC-USDT',
            //     ), // 结果集
            // );
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbolId = $market['id'];
            $messageHash = 'update.quote:' . $symbolId;
            $type_ = 'spot';
            $url = $this->urls['api']['ws'][$type_];
            $request = array(
                'method' => 'subscribe.quote',
                'params' => array(
                    'market' => $symbolId,
                ),
                'id' => $this->request_id(),
            );
            $ticker = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $ticker;
        }) ();
    }

    public function watch_tickers($symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             * @see https://allinexchange.github.io/spot-docs/v1/en/#websocket-guide
             * @param {string[]} $symbols unified symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $messageHash = 'update.quotes';
            $type_ = 'spot';
            $url = $this->urls['api']['ws'][$type_];
            $request = array(
                'method' => 'subscribe.quotes',
                'params' => array(),
                'id' => $this->request_id(),
            );
            $tickers = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $this->filter_by_array($tickers, 'symbol', $symbols);
        }) ();
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->portfolioMargin] set to true if you would like to watch the balance of a portfolio margin account
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             */
            Async\await($this->load_markets());
            $currentType = $this->safe_string($params, 'defaultType', null);
            if (!$currentType) {
                $currentType = $this->options['defaultType'];
            }
            $url = $this->urls['api']['ws'][$currentType];
            Async\await($this->authenticate($url));
            $messageHash = 'update.asset';
            $request = array(
                'method' => 'subscribe.asset',
                'params' => array(),
                'id' => $this->request_id(),
            );
            $balances = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            return $balances;
        }) ();
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            $currentType = $this->safe_string($params, 'defaultType', null);
            if (!$currentType) {
                $currentType = $this->options['defaultType'];
            }
            Async\await($this->load_markets());
            if ($currentType === 'future' || $currentType === 'swap') {
                $messageHash = 'update.position';
                $url = $this->urls['api']['ws'][$currentType];
                Async\await($this->authenticate($url));
                $request = array(
                    'method' => 'subscribe.position',
                    'id' => $this->request_id(),
                    'params' => array(),
                );
                $positions = Async\await($this->watch($url, $messageHash, $request, $messageHash));
                return $positions;
            } else {
                throw new BaseError($currentType . 'market type no position');
            }
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            $currentType = $this->safe_string($params, 'defaultType', null);
            $type_ = null;
            $marketId = null;
            $messageHash = null;
            if ($symbol === null && $currentType === 'spot') {
                throw new ArgumentsRequired($this->id . ' watchOrderBook() requires a $symbol argument');
            } elseif ($symbol !== null) {
                Async\await($this->load_markets());
                $market = $this->market($symbol);
                $marketId = $market['id'];
                $type_ = $market['type'];
                $messageHash = 'orders:' . $marketId;
            } else {
                $type_ = $currentType;
                $messageHash = 'orders:__ALL__';
            }
            $url = $this->urls['api']['ws'][$type_];
            Async\await($this->authenticate($url));
            $request = null;
            if ($type_ === 'spot') {
                $request = array(
                    'method' => 'subscribe.orders',
                    'params' => array(),
                    'id' => $this->request_id(),
                );
            } else {
                $request = array(
                    'method' => 'subscribe.order',
                    'params' => array(),
                    'id' => $this->request_id(),
                );
            }
            if ($marketId !== null) {
                $request['params']['market'] = $marketId;
            }
            $orders = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $orders;
        }) ();
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             * @see https://allinexchange.github.io/spot-docs/v1/en/#subscription-topic
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $type_ = $market['type'];
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $url = $this->urls['api']['ws'][$type_];
            $reqId = $this->request_id();
            if (!$market['spot']) {
                $interval = strtolower('strval' ($interval));
            }
            $messageHash = 'kline:' . $interval . ':' . $marketId;
            $request = array(
                'method' => 'subscribe.kline',
                'params' => array(
                    'period' => $interval,
                    'market' => $marketId,
                ),
                'id' => $reqId,
            );
            $ohlcv = Async\await($this->watch($url, $messageHash, $request, $messageHash, true));
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function authenticate($url, $params = array ()) {
        return Async\async(function () use ($url, $params) {
            $this->check_required_credentials();
            $messageHash = 'sign';
            $currentType = $this->safe_string($params, 'defaultType', null);
            if (!$currentType) {
                $currentType = $this->options['defaultType'];
            }
            $client = $this->client($url);
            $future = $client->future ($messageHash);
            $authenticated = $this->safe_value($client->subscriptions, $messageHash);
            $request = array();
            if ($authenticated === null) {
                $nonce = (string) $this->nonce();
                $ts = $nonce;
                $client_id = $this->apiKey;
                $s = 'client_id=' . $client_id . '&$nonce=' . $nonce . '&$ts=' . $ts;
                $v = $this->hmac($this->encode($s), $this->encode($this->secret), 'sha256');
                $request = array( 'method' => 'sign',
                    'id' => $this->request_id(),
                    'params' => array( 'client_id' => $client_id,
                        'ts' => $ts,
                        'nonce' => $nonce,
                        'sign' => $v ));
                $this->watch($url, $messageHash, $request, $messageHash);
            }
            return Async\await($future);
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        // $response = array( 'id' => 100,
        //     'method' => 'update.depth',
        //     'result' => array( 'data':
        //         array( 'asks' => array( array( 'price' => '68000.0', 'quantity' => '0.357100' ),
        //             array( 'price' => '68123.5', 'quantity' => '0.230000' ) ),
        //            'bids' => array( array( 'price' => '67890.9', 'quantity' => '0.002000' ),
        //             array( 'price' => '67890.4', 'quantity' => '0.001000' ),
        //             array( 'price' => '65000.2', 'quantity' => '0.300000' ),
        //             array( 'price' => '62000.0', 'quantity' => '1.999000' ),
        //             array( 'price' => '60000.0', 'quantity' => '1.100000' ),
        //             array( 'price' => '8850.2', 'quantity' => '0.200000' ) ),
        //              'symbol' => 'BTC-USDT',
        //              'timestamp' => 1721550307627,
        //              'topic' => 'depth:step1:BTC-USDT',
        //              'tpp' => 7 ),
        //          'merge' => 'step1' ),
        //     'error' => null );
        // future
        // {
        //     "id":0,
        //     "method":"update.depth",
        //     "result":array(
        //       "asks":array(
        //         array(
        //           "36341.6",
        //           "0.0444"
        //         )
        //       ),
        //       "bids":array(
        //         array(
        //           "36341.25",
        //           "0.0511"
        //         )
        //       ),
        //       "index_price":"36612.36",
        //       "last":"36341.59",
        //       "market":"BTCUSDT",
        //       "sign_price":"36589.76",
        //       "time":1699944061967
        //     ),
        //     "error":null
        //   }
        $result = $this->safe_dict($message, 'result');
        $marketId = $this->safe_string($result, 'market', null);
        $timestamp = null;
        $abData = null;
        if ($marketId === null) {
            // spot
            $abData = $this->safe_dict($result, 'data');
            $marketId = $this->safe_string($abData, 'symbol');
            $timestamp = $this->safe_integer($abData, 'timestamp');
        } else {
            // future
            $abData = $result;
            $marketId = $this->safe_string($abData, 'market');
            $timestamp = $this->safe_integer($abData, 'time');
        }
        $market = $this->safe_market($marketId, null, null);
        $messageHash = 'depth:' . ':' . $marketId;
        $symbol = $market['symbol'];
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
            $this->orderbooks[$symbol]['symbol'] = $symbol;
        }
        $orderbook = $this->orderbooks[$symbol];
        $snapshot = null;
        if ($market['spot']) {
            $snapshot = $this->parse_order_book($abData, $symbol, $timestamp, 'bids', 'asks', 'price', 'quantity');
            $orderbook->reset ($snapshot);
        } else {
            $snapshot = $this->parse_order_book($abData, $symbol, $timestamp, 'bids', 'asks', 0, 1);
            $orderbook->reset ($snapshot);
            $orderbook['markPrice'] = $this->safe_float($result, 'sign_price');
            $orderbook['indexPrice'] = $this->safe_float($result, 'index_price');
            $orderbook['lastPrice'] = $this->safe_float($result, 'last');
        }
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_fulls($datas) {
        $bookside = array();
        for ($i = 0; $i < count($datas); $i++) {
            $bookside[] = $this->safe_float($datas, 'price'), $this->safe_float($datas, 'quantity');
        }
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 'price');
        $amount = $this->safe_float($delta, 'quantity');
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_ticker(Client $client, $message) {
        // $ticker = array(
        //     'id' => 1,
        //     'method' => 'update.quote',
        //     'error' => null,
        //     'result' => array(
        //         'data' => array(
        //             'symbol' => 'BTC-USDT',
        //             'timestamp' => 1673417148,
        //             'topic' => 'quotes',
        //             'price' => '100.21',
        //             'volume' => '0',
        //             'amount' => '0',
        //             'high' => '100.21',
        //             'low' => '100.21',
        //             'change' => '0',
        //             'tpp' => 1,
        //             'l_price' => '100.21',
        //         ),
        //         'market' => 'BTC-USDT',
        //     ),
        // );
        // future
        // {
        //     "id":0,
        //     "method":"update.state",
        //     "result" => {
        //       "1000SHIBUSDT" => array(
        //         "market" => "1000SHIBUSDT",
        //         "amount" => "35226256.573504",
        //         "high":"0.009001",
        //         "last" => "0.008607",
        //         "low" => "0.008324",
        //         "open" => "0.008864",
        //         "period" => 86400,
        //         "volume":"4036517772",
        //         "change" => "-0.0289936823104693",
        //         "funding_time" => 79,
        //         "position_amount" => "0",
        //         "funding_rate_last" => "0.00092889",
        //         "funding_rate_next":"0.00078062",
        //         "funding_rate_predict" => "0.00059084",
        //         "insurance" => "12920.37897885999447286856",
        //         "sign_price" => "0.008607",
        //         "index_price" => "0.008606",
        //         "sell_total":"46470921",
        //         "buy_total" => "43420303"
        //       }
        //     ),
        //     "error":null
        //   }
        $result = $this->safe_dict($message, 'result');
        $tickerData = $this->safe_dict($result, 'data');
        if ($tickerData === null) {
            // future
            $keys = is_array($result) ? array_keys($result) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $symbolId = $keys[$i];
                $messageHash = 'update.quote:' . $symbolId;
                $market = $this->safe_market($symbolId);
                $symbol = $market['symbol'];
                $data = $result[$symbolId];
                $ticker = $this->parse_ticker($data, $market);
                $this->tickers[$symbol] = $ticker;
                $client->resolve ($ticker, $messageHash);
            }
        } else {
            // spot
            $symbolId = $this->safe_string($tickerData, 'symbol');
            $market = $this->safe_market($symbolId, null, null);
            $tickerData['timestamp'] = $this->safe_timestamp($tickerData, 'timestamp');
            $symbol = $market['symbol'];
            $messageHash = 'update.quote:' . $symbolId;
            $ticker = $this->parse_ticker($tickerData, $market);
            $this->tickers[$symbol] = $ticker;
            $client->resolve ($ticker, $messageHash);
        }
    }

    public function handle_tickers(Client $client, $message) {
        // $ticker = array(
        //     'id' => 1,
        //     'method' => 'update.quotes',
        //     'error' => null,
        //     'result' => array(
        //         'data' => array(
        //             'symbol' => 'BTC-USDT',
        //             'timestamp' => 1673417148,
        //             'topic' => 'quotes',
        //             'price' => '100.21',
        //             'volume' => '0',
        //             'amount' => '0',
        //             'high' => '100.21',
        //             'low' => '100.21',
        //             'change' => '0',
        //             'tpp' => 1,
        //             'l_price' => '100.21',
        //         ),
        //         'market' => 'BTC-USDT',
        //     ),
        // );
        $result = $this->safe_dict($message, 'result');
        $tickerData = $this->safe_dict($result, 'data');
        $symbolId = $this->safe_string($tickerData, 'symbol');
        $market = $this->safe_market($symbolId, null, null);
        $tickerData['timestamp'] = $this->safe_timestamp($tickerData, 'timestamp');
        $symbol = $market['symbol'];
        $messageHash = 'update.quotes';
        $ticker = $this->parse_ticker($tickerData, $market);
        $this->tickers[$symbol] = $ticker;
        $client->resolve ($this->tickers, $messageHash);
    }

    public function handle_ohlcv(Client $client, $message) {
        // $message = array(
        //     'id' => 1,
        //     'method' => 'update.kline',
        //     'error' => null, // 错误响应
        //     'result' => array(
        //         'data' => array(
        //             'symbol' => 'BTC-USDT',
        //             'ticks' => array(
        //                 array(
        //                     'close' => '101.000000',
        //                     'high' => '101.000000',
        //                     'low' => '101.000000',
        //                     'open' => '101.000000',
        //                     'timestamp' => 1672910460,
        //                     'volume' => '0',
        //                 ),
        //             ),
        //             'timestamp' => 1721551500,
        //             'topic' => 'kline:1Min:BTC-USDT',
        //             'tpp' => 1,
        //             'type' => '1Min',
        //         ), // 返回数据
        //         'period' => '1Min',
        //     ), // 结果集
        // );
        // $future
        // $future = array( 'id' => 0,
        //     'method':
        //     'update.kline',
        //     'result' => array( 'data' => array( array( 1723034940, '65517.74', '65517.74', '65517.74', '65517.74', '0', '0', 'BTCUSDT' ) ),
        //         'market' => 'BTCUSDT',
        //         'period' => '1min' ),
        //     'error' => null );
        $result = $this->safe_dict($message, 'result');
        if ($result === null) {
            return;
        }
        $klineData = $this->safe_dict($result, 'data');
        $marketId = $this->safe_string_2($klineData, 'symbol', 'market', null);
        if ($marketId === null) {
            // $future
            $marketId = $this->safe_string($result, 'market');
        }
        $market = $this->safe_market($marketId, null, null);
        $symbol = $market['symbol'];
        $messageHash = null;
        $ticks = null;
        $timeframeId = null;
        $timeframe = null;
        if ($market['spot']) {
            $ticks = $this->safe_list($klineData, 'ticks');
            $timeframeId = $this->safe_string($klineData, 'type');
            $messageHash = $this->safe_string($klineData, 'topic');
            $timeframe = $this->find_timeframe($timeframeId);
        } else {
            $ticks = $this->safe_list($result, 'data');
            $timeframeId = $this->safe_string($result, 'period');
            $timeframe = $this->parseLowerTimeframe ($timeframeId);
            $messageHash = 'kline:' . strtolower('strval' ($timeframeId)) . ':' . $marketId;
        }
        $ohlcvsByTimeframe = $this->safe_value($this->ohlcvs, $symbol);
        if ($ohlcvsByTimeframe === null) {
            $this->ohlcvs[$symbol] = array();
        }
        $stored = $this->safe_value($ohlcvsByTimeframe, $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        for ($i = 0; $i < count($ticks); $i++) {
            $tick = $ticks[$i];
            $parsed = $this->parse_ohlcv($tick, $market);
            $stored->append ($parsed);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function handle_order(Client $client, $message) {
        // $orderMessage = array(
        //     'id' => 0,
        //     'method' => 'update.orders',
        //     'result' => array(
        //         'frm' => 'USDT',
        //         'left' => '0.100000',
        //         'match_amt' => '0',
        //         'match_price' => '60000.21',
        //         'match_qty' => '0',
        //         'order_id' => '102',
        //         'order_sub_type' => 0,
        //         'order_type' => 1,
        //         'price' => '60000.21',
        //         'quantity' => '0.100000',
        //         'real_order_id' => '102',
        //         'side' => 1,
        //         'status' => 2,
        //         'stop_price' => '0',
        //         'symbol' => 'BTC-USDT',
        //         'ticker_id' => 7,
        //         'timestamp' => 1721031092,
        //         'update_timestamp' => 1721031092,
        //         'to' => 'BTC',
        //         'topic' => 'orders:BTC-USDT',
        //         'tpp' => 7,
        //         'trade_no' => '40545373062180505095221',
        //     ),
        //     'error' => null,
        // );
        // future
        // $futureOrder = array( 'id' => 0,
        //     'method' => 'update.order',
        //     'result' => array( 'order_id' => 5034339,
        //         'position_id' => 0,
        //         'market' => 'BTCUSDT',
        //         'type' => 1,
        //         'side' => 1,
        //         'left' => '0.0000',
        //         'amount' => '0.0400',
        //         'filled' => '0.04',
        //         'deal_fee' => '0.9583',
        //         'price' => '56000',
        //         'avg_price' => '59898.36',
        //         'deal_stock' => '2395.9344',
        //         'position_type' => 2,
        //         'leverage' => '100',
        //         'update_time' => 1723131121.719404,
        //         'create_time' => 1723131121.719389,
        //         'status' => 3,
        //         'stop_loss_price' => '-',
        //         'take_profit_price' => '-' ),
        //     'error' => None );
        $result = $this->safe_dict($message, 'result');
        $allinSymbol = $this->safe_string_2($result, 'symbol', 'market');
        $market = $this->safe_market($allinSymbol);
        if (!$market) {
            return;
        }
        $order = $this->parse_order($result, $market);
        $messageHashAll = null;
        $messageHash = 'orders:' . $market['id'];
        if ($market['spot']) {
            $messageHashAll = 'orders:__ALL__';
        }
        $safeOrder = $this->safe_order($order, $market);
        $client->resolve (array( $safeOrder ), $messageHash);
        if ($messageHashAll) {
            $client->resolve (array( $safeOrder ), $messageHashAll);
        }
    }

    public function handle_balance(Client $client, $message) {
        // {
        //     "id" => 1,
        //     "method" => "update.asset",
        //     "error" => null, //错误响应
        //     "result" => {
        //         "available" => "999909.4",
        //         "freeze" => "90.6",
        //         "symbol" => "USDT",
        //         "topic" => "accounts",
        //         "total" => "1000000"
        //     } //结果集
        // }
        // future
        // {
        //     "id":0,
        //     "method":"update.asset",
        //     "result":{
        //       "USDT":array(
        //         "available":"10320.9887",
        //         "frozen":"0",
        //         "margin":"16.1356",
        //         "balance_total":"10320.9887",
        //         "profit_unreal":"11.0315",
        //         "transfer":"10097.1501",
        //         "bonus":"223.8386"
        //       }
        //     ),
        //     "error":null
        //   }
        $currentType = $this->safe_string($this->options, 'defaultType', null);
        $messageHash = 'update.asset';
        if ($this->balance === null) {
            $this->balance = array();
        }
        if (!$this->safe_dict($this->balance, 'info')) {
            $this->balance['info'] = array();
        }
        if ($currentType === 'spot') {
            $result = $this->safe_dict($message, 'result');
            $token = $this->safe_string($result, 'symbol');
            $this->balance['info'][$token] = $result;
            $timestamp = $this->milliseconds();
            $this->balance['timestamp'] = $timestamp;
            $this->balance['datetime'] = $this->iso8601($timestamp);
            $this->balance[$token] = array(
                'free' => $this->safe_string($result, 'available'),
                'total' => $this->safe_string($result, 'total'),
                'used' => $this->safe_string($result, 'freeze'),
            );
        } else {
            $originBalances = $this->safe_dict($message, 'result');
            $keys = is_array($originBalances) ? array_keys($originBalances) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $originBalance = $originBalances[$key];
                $symbol = $key;
                $used = $this->safe_string($originBalance, 'frozen');
                $total = $this->safe_string($originBalance, 'balance_total');
                $free = $this->safe_string($originBalance, 'available');
                $this->balance[$symbol] = array(
                    'free' => $free,
                    'used' => $used,
                    'total' => $total,
                    'debt' => 0, // ???
                );
            }
        }
        $this->balance = $this->safe_balance($this->balance);
        $client->resolve ($this->balance, $messageHash);
    }

    public function handle_positions(Client $client, $message) {
        // {
        //     "id":0,
        //     "method":"update.position",
        //     "result":{
        //       "event":1,
        //       "position":array(
        //         "position_id":4784242,
        //         "create_time":1699944061.968543,
        //         "update_time":1699944061.968656,
        //         "user_id":9108,
        //         "market":"BTCUSDT",
        //         "type":2,
        //         "side":2,
        //         "amount":"0.0444",
        //         "close_left":"0.0444",
        //         "open_price":"36341.6",
        //         "open_margin":"6.4063",
        //         "margin_amount":"16.1356",
        //         "leverage":"100",
        //         "profit_unreal":"11.0184",
        //         "liq_price":"0",
        //         "mainten_margin":"0.005",
        //         "mainten_margin_amount":"8.0678",
        //         "adl_sort":1,
        //         "roe":"0.6828",
        //         "margin_ratio":"",
        //         "stop_loss_price":"-",
        //         "take_profit_price":"-"
        //       }
        //     ),
        //     "error":null
        //   }
        $result = $this->safe_dict($message, 'result');
        $data = $this->safe_dict($result, 'position');
        $marketId = $data['market'];
        $market = $this->safe_market($marketId);
        $messageHash = 'update.position';
        if ($this->positions === null) {
            $this->positions = new ArrayCacheBySymbolBySide ();
        }
        $cache = $this->positions;
        $position = $this->parse_position($data, $market);
        $cache->append ($position);
        $client->resolve (array( $position ), $messageHash);
    }

    public function ping($client) {
        return array(
            'id' => $this->request_id(),
            'method' => 'ping',
            'params' => array(),
        );
    }

    public function handle_pong($client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_authenticate(Client $client, $message) {
        // array( id => 1, method => 'sign', result => 'login success', $error => null )
        $errorStr = $message['error'];
        $messageHash = 'sign';
        if (!$errorStr) {
            $future = $this->safe_value($client->futures, $messageHash);
            $future->resolve (true);
        } else {
            $error = new AuthenticationError ($this->id . ' ' . $this->json($errorStr));
            $client->reject ($error, $messageHash);
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions[$messageHash]);
            }
        }
        return $message;
    }

    public function handle_error_message(Client $client, $message): bool {
        // $response = array( 'id' => 100,
        //     'method' => 'update.depth',
        //     'result' => array( 'data':
        //         array( 'asks' => array( array( 'price' => '68000.0', 'quantity' => '0.357100' ),
        //             array( 'price' => '68123.5', 'quantity' => '0.230000' ) ),
        //         'bids' => array( array( 'price' => '67890.9', 'quantity' => '0.002000' ),
        //             array( 'price' => '67890.4', 'quantity' => '0.001000' ),
        //             array( 'price' => '65000.2', 'quantity' => '0.300000' ),
        //             array( 'price' => '62000.0', 'quantity' => '1.999000' ),
        //             array( 'price' => '60000.0', 'quantity' => '1.100000' ),
        //             array( 'price' => '8850.2', 'quantity' => '0.200000' ) ),
        //         'symbol' => 'BTC-USDT',
        //         'timestamp' => 1720856594882,
        //         'topic' => 'depth:step1:BTC-USDT',
        //         'tpp' => 7 ),
        //     'merge' => 'step1' ),
        //     'error' => null );
        // future
        // {'id' => 1,
        //     'method' => 'subscribe.sign',
        //     'result' => None,
        //     'error' => array('code' => 20015, 'msg' => 'system error')
        // }
        $error = $message['error'];
        if ($error) {
            $code = $this->safe_string($error, 'code', 'default');
            $errorStr = null;
            if ($code !== null) {
                $errorStr = $this->safe_string($error, 'msg');
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $errorStr);
            } else {
                $code = ' ';
                $errorStr = $error;
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $errorStr);
            }
        }
        return false;
    }

    public function handle_message(Client $client, $message) {
        $error = $this->safe_value($message, 'error');
        if ($error) {
            $this->handle_error_message($client, $message);
        }
        // 'subscribe.depth' => array($this, 'handle_order_book'),
        // 'subscribe.kline' => array($this, 'handle_ohlcv'),
        $methodsDict = array(
            'update.depth' => array($this, 'handle_order_book'),
            'update.kline' => array($this, 'handle_ohlcv'),
            'update.orders' => array($this, 'handle_order'),
            'update.order' => array($this, 'handle_order'),
            'update.asset' => array($this, 'handle_balance'),
            'ping' => array($this, 'handle_pong'),
            'sign' => array($this, 'handle_authenticate'),
            'update.quote' => array($this, 'handle_ticker'),
            'update.quotes' => array($this, 'handle_tickers'),
            'update.position' => array($this, 'handle_positions'),
        );
        $methodStr = $this->safe_string($message, 'method');
        $method = $this->safe_value($methodsDict, $methodStr);
        if ($method) {
            $method($client, $message);
        }
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }
}
